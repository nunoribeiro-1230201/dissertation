% we include the glossary here (frontmatter is included with \input, so this command is as if it was in main.tex)
\input{frontmatter/glossary}

\frontmatter % Use roman page numbering style (i, ii, iii, iv...) for the pre-content pages

\pagestyle{plain} % Default to the plain heading style until the thesis style is called for the body content

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\maketitlepage

%----------------------------------------------------------------------------------------
%	STATEMENT of INTEGRITY
%----------------------------------------------------------------------------------------
\integritystatement

%----------------------------------------------------------------------------------------
%	DEDICATION  (optional)
%----------------------------------------------------------------------------------------
%
%\dedicatory{For/Dedicated to/To my\ldots}
%\begin{dedicatory}
%The dedicatory is optional. Below is an example of a humorous dedication.

%\end{dedicatory}

%----------------------------------------------------------------------------------------
%	ABSTRACT PAGE
%----------------------------------------------------------------------------------------

\begin{abstract}

% here you put the abstract in the main language of the work.
Fault tolerance is a critical component of distributed systems, particularly taking in account the exponential growth in internet usage and system scale in recent years. The resilience and fault tolerance capabilities of these systems are essential for maintaining reliability and minimizing downtime. Elixir, with its fault-tolerant features and its foundation in Erlang’s “let it crash” philosophy, stands out as a robust tool for building such systems.

Nevertheless, other distributed and concurrent programming languages also offer solutions, often leveraging similar concepts in different environments. For instance, Akka, inspired by the “let it crash” philosophy, provides a toolkit built for Scala. While both languages share conceptual foundations, Scala operates in a different environment with unique characteristics. Meanwhile, Go, a language gaining widespread popularity for its strong concurrency mechanisms, offers another compelling option for building concurrent and fault-tolerant systems.

Although all these languages can theoretically employ the Actor Model through libraries and toolkits, Elixir integrates these concepts natively, potentially providing distinct advantages. Conversely, Scala and Go include features that are not inherently available in Elixir’s Open Telecom Platform (OTP), such as replication on Akka, for example. Moreover, Go’s lack of native support for distributed systems raises questions about whether the advantages of using a widely adopted language can limiting on distributed computing compared with specific focus languages.

To investigate these assumptions and evaluate the comparative strengths and weaknesses of each language, benchmarking is necessary. Based on a review of existing literature, the most effective methodology, for this case, involves designing a generic application that simulates distributed operations sensitive to fault tolerance and resilience. This application will enable the creation of controlled test scenarios to yield measurable results, offering insights into the performance of each language in building fault-tolerant systems.

Future work will focus on implementing the benchmarking strategies, collecting performance, fault tolerance, and resilience metrics, as well as static code metrics. These efforts will be supported by detailed project planning to ensure the successful execution and meaningful outcomes of the project.

\end{abstract}

\begin{abstractotherlanguage}
% here you put the abstract in the "other language": English,m if the work is written in Portuguese; Portuguese, if the work is written in English.

% Para alterar a língua basta ir às configurações do documento no ficheiro \file{main.tex} e alterar para a língua desejada ('english' ou 'portuguese')\footnote{Alterar a língua requer apagar alguns ficheiros temporários; O target \keyword{clean} do \keyword{Makefile} incluído pode ser utilizado para este propósito.}. Isto fará com que os cabeçalhos incluídos no template sejam traduzidos para a respetiva língua.

A tolerância a falhas é um componente fundamental dos sistemas distribuídos, especialmente tendo em conta o grande crescimento da utilização da Internet e a crescente necessidade de sistemas mais robustos nos últimos anos. As capacidades de resiliência e tolerância a falhas destes sistemas são essenciais para garantir a fiabilidade e minimizar o tempo de inatividade devido a falhas. Elixir, com as suas características de tolerância a falhas e tendo a sua base na filosofia \textit{“let it crash”} de Erlang, destaca-se como uma ferramenta poderosa para a construção destes sistemas. Elixir herda todas as capacidades de Erlang, assim como da sua \textit{virtual machine}, sendo projetado para garantir alta disponibilidade nos diversos sistemas em que é utilizado, como, por exemplo, em bancos e telecomunicações.

Contudo, outras linguagens de programação distribuídas e concorrentes também oferecem soluções, muitas vezes aproveitando conceitos semelhantes em ambientes distintos, ou até mesmo inspirando-se na solução oferecida por Elixir, adaptando-a aos seus próprios conceitos, ou utilizando abordagens diferentes mas com objetivos semelhantes. Por exemplo, Akka, inspirado pela filosofia \textit{“let it crash”}, fornece um conjunto de ferramentas criado para Scala, permitindo imitar o comportamento visto em Elixir com o uso de padrões \textit{supervisor}. Embora ambas as linguagens compartilhem a mesma filosofia, o Scala opera num ambiente diferente, com características únicas, funcionando sobre a \textit{Java Virtual Machine} (JVM). Por outro lado, Go, uma linguagem que tem ganho popularidade devido aos seus mecanismos de concorrência robustos e ao seu uso em vários projetos \textit{cloud-based} de grande escala, adota uma abordagem diferente e oposta quanto ao controlo de erros, sendo mais explícita e rejeitando a ideia de que os erros devem ser tidos como inevitáveis, sem a necessidade de um controlo tão explícito dentro dos componentes.

Embora todas estas linguagens possam teoricamente empregar o \textit{Actor Model} através de bibliotecas e kits de ferramentas, como Akka faz em Scala e o Proto-Actor em Go, Elixir integra esses conceitos de forma nativa, o que pode teoricamente oferecer vantagens. Por outro lado, Scala e Go incluem funcionalidades que não estão presentes na \textit{Open Telecom Platform} (OTP) do Elixir. Além disso, a falta de suporte nativo de Go para sistemas distribuídos levanta questões sobre a conveniência de utilizar uma linguagem amplamente adotada, mas com limitações na computação distribuída, quando comparada com linguagens mais específicas para este fim. Assim, o objetivo é perceber se, para a criação de um sistema tolerante a falhas, a utilização de uma linguagem nativa como o Elixir compensa em comparação com a utilização de uma linguagem mais genérica, mas com maior popularidade.

Para investigar estes pressupostos e avaliar as vantagens e desvantagens de cada linguagem, será necessário realizar uma avaliação comparativa através de \textit{benchmarking}. Com base numa revisão da literatura existente, a metodologia mais eficaz para este caso envolve a criação de uma aplicação genérica que simule operações distribuídas sensíveis à tolerância a falhas e resiliência. Esta abordagem, combinando diferentes métodos utilizados na literatura, permite a criação de cenários de teste controlados em sistemas que tentam imitar processos reais, gerando resultados mensuráveis.

O trabalho futuro concentrar-se-á na implementação de um \textit{benchmarking} detalhado, na análise e recolha de métricas, bem como na apresentação das conclusões. A abordagem proposta envolve o desenvolvimento de uma aplicação de \textit{chat} que suporte funcionalidades básicas, sendo implementada nas três linguagens selecionadas. No caso da linguagem Go, serão realizadas duas implementações: uma utilizando o \textit{Actor Model} através do \textit{toolkit} Proto-Actor e outra adotando abordagens nativas para distribuição e mecanismos de tolerância a falhas próprios da linguagem e de bibliotecas externas.

A execução desta análise permitirá a obtenção de métricas relacionadas à \textit{performance}, à tolerância a falhas e resiliência, complementadas por uma análise estática do código. Estes esforços serão conduzidos com o apoio de um planeamento detalhado, no qual todas as fases do projeto estão descritas e os entregáveis devidamente definidos.

\end{abstractotherlanguage}

%----------------------------------------------------------------------------------------
%	ACKNOWLEDGEMENTS (optional)
%----------------------------------------------------------------------------------------

% \begin{acknowledgements}

% The optional Acknowledgment goes here\ldots Below is an example of a humorous acknowledgment.

%\end{acknowledgements}

%----------------------------------------------------------------------------------------
%	LIST OF CONTENTS/FIGURES/TABLES PAGES
%----------------------------------------------------------------------------------------

\tableofcontents % Prints the main table of contents

\listoffigures % Prints the list of figures

\listoftables % Prints the list of tables

\begin{comment}
\iflanguage{portuguese}{
\renewcommand{\listalgorithmname}{Lista de Algor\'itmos}
}
\listofalgorithms % Prints the list of algorithms
\addchaptertocentry{\listalgorithmname}



\renewcommand{\lstlistlistingname}{List of Source Code}
\iflanguage{portuguese}{
\renewcommand{\lstlistlistingname}{Lista de C\'odigo}
}
\lstlistoflistings % Prints the list of listings (programming language source code)
\addchaptertocentry{\lstlistlistingname}
\end{comment}


%----------------------------------------------------------------------------------------
%	ABBREVIATIONS
%----------------------------------------------------------------------------------------
%\begin{abbreviations}{ll} % Include a list of abbreviations (a table of two columns)
%%\textbf{LAH} & \textbf{L}ist \textbf{A}bbreviations \textbf{H}ere\\
%%\textbf{WSF} & \textbf{W}hat (it) \textbf{S}tands \textbf{F}or\\
%\end{abbreviations}

%----------------------------------------------------------------------------------------
%	SYMBOLS
%----------------------------------------------------------------------------------------

%\begin{symbols}{lll} % Include a list of Symbols (a three column table)

%$a$ & distance & \si{\meter} \\
%$P$ & power & \si{\watt} (\si{\joule\per\second}) \\
%Symbol & Name & Unit \\

%\addlinespace % Gap to separate the Roman symbols from the Greek

%$\omega$ & angular frequency & \si{\radian} \\

%\end{symbols}



%----------------------------------------------------------------------------------------
%	ACRONYMS
%----------------------------------------------------------------------------------------

\newcommand{\listacronymname}{List of Acronyms}
\iflanguage{portuguese}{
\renewcommand{\listacronymname}{Lista de Acr\'onimos}
}

%Use GLS
%\glsresetall
\printglossary[title=\listacronymname,type=\acronymtype,style=long]

%----------------------------------------------------------------------------------------
%	DONE
%----------------------------------------------------------------------------------------

\mainmatter % Begin numeric (1,2,3...) page numbering
\pagestyle{thesis} % Return the page headers back to the "thesis" style
