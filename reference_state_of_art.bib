@inproceedings{Valkov2018,
  abstract  = {Servers are a key element of current IT infrastructures, and must often deal with large numbers of concurrent requests. The programming language used to construct the server has an important role in engineering efficient server software, and must support massive concurrency on multicore machines with low communication and synchronisation overheads. This paper investigates 12 highly concurrent programming languages suitable for engineering servers, and analyses three representative languages in detail: Erlang, Go, and Scala with Akka. We have designed three server benchmarks that analyse key performance characteristics of the languages. The benchmark results suggest that where minimising message latency is crucial, Go and Erlang are best; that Scala with Akka is capable of supporting the largest number of dormant processes; that for servers that frequently spawn processes Erlang and Go minimise creation time; and that for constantly communicating processes Go provides the best throughput.},
  author    = {Ivan Valkov and Natalia Chechina and Phil Trinder},
  doi       = {10.1145/3167132.3167144},
  isbn      = {9781450351911},
  booktitle = {Proceedings of the ACM Symposium on Applied Computing},
  keywords  = {Akka,Erlang,Go,Programming languages,Scala,Server applications},
  month     = {4},
  pages     = {218-225},
  publisher = {Association for Computing Machinery},
  title     = {Comparing languages for engineering server software: Erlang, go, and scala with akka},
  year      = {2018}
}
@misc{Cutajar2023,
  author = {James Cutajar},
  isbn   = {9781633438385},
  title  = {Learn Concurrent Programming with Go},
  year   = {2023}
}
@book{Abraham2023,
  author    = {Francisco Lopez-Sancho Abraham},
  isbn      = {9781617299216},
  publisher = {Simon and Schuster},
  title     = {Akka in Action, Second Edition},
  year      = {2023}
}
@book{Juric2024,
  author = {Saša Jurić and Francesco Cesarini},
  isbn   = {9781633438514},
  pmid   = {9781633438514},
  title  = {Elixir in Action, Third Edition},
  year   = {2024}
}
@article{LeBrun2021,
  author    = {Matthew Alan Le Brun and Duncan Paul Attard and Adrian Francalanza},
  city      = {New York, NY, USA},
  doi       = {10.1145/3471871.3472963},
  isbn      = {9781450386128},
  journal   = {Proceedings of the 20th ACM SIGPLAN International Workshop on Erlang},
  month     = {8},
  pages     = {2-14},
  publisher = {ACM},
  title     = {Graft: general purpose raft consensus in Elixir},
  year      = {2021}
}
@inproceedings{Cassola2020,
  abstract  = {Elixir is a functional programming language with dynamic typing. In this paper we propose a type system that makes it possible to perform static type-checking on a significant fragment of Elixir. An important feature of the type system we introduce is that it does not require any syntactic change to the language. Type information is provided by means of function signatures which are declared in terms of Elixir typespec directives. The proposed type system is based on subtyping and is backward compatible, as it allows the presence of untyped code fragments. We have implemented a prototype of the type-checker in Elixir itself.},
  author    = {Mauricio Cassola and Agustín Talagorria and Alberto Pardo and Marcos Viera},
  doi       = {10.1145/3427081.3427084},
  isbn      = {9781450389433},
  booktitle = {ACM International Conference Proceeding Series},
  keywords  = {elixir,functional programming,gradual typing,static typing},
  month     = {10},
  pages     = {17-24},
  publisher = {Association for Computing Machinery},
  title     = {A Gradual Type System for Elixir},
  year      = {2020}
}
@inproceedings{Moamen2027,
  abstract  = {Although there are models and prototype implementations for controlling resource use in Actor systems, they are difficult to implement for production implementations of Actors such as Akka. This is because the messaging and scheduling infrastructures of runtime systems are increasingly complex and significantly different from one system to another. This paper presents our efforts in implementing resource control support for Actor systems implemented using the Akka library. Particularly, given the lack of support in Akka for direct scheduling of actors, we compare two different ways of approximating actor-level control support. The first implementation expects messages to actors to provide estimates of resources likely to be consumed for processing them; these estimates are then relied upon to make scheduling decisions. In the second implementation, resource use of scheduled actors is tracked, and compared against allocations to decide when they should be scheduled next. We present experimental results on the performance cost of these resource control mechanisms, as well as their impact on resource utilization.},
  author    = {Ahmed Abdel Moamen and Dezhong Wang and Nadeem Jamali},
  doi       = {10.1109/ICDCS.2017.291},
  isbn      = {9781538617915},
  booktitle = {Proceedings - International Conference on Distributed Computing Systems},
  keywords  = {Actors,Akka,Resource Control,Scala},
  month     = {7},
  pages     = {2642-2645},
  publisher = {Institute of Electrical and Electronics Engineers Inc.},
  title     = {Supporting Resource Control for Actor Systems in Akka},
  year      = {2017}
}
@article{Bagherzadeh2020,
  abstract  = {Actor concurrency is becoming increasingly important in the development of real-world software systems. Although actor concurrency may be less susceptible to some multithreaded concurrency bugs, such as low-level data races and deadlocks, it comes with its own bugs that may be different. However, the fundamental characteristics of actor concurrency bugs, including their symptoms, root causes, API usages, examples, and differences when they come from different sources are still largely unknown. Actor software development can significantly benefit from a comprehensive qualitative and quantitative understanding of these characteristics, which is the focus of this work, to foster better API documentation, development practices, testing, debugging, repairing, and verification frameworks. To conduct this study, we take the following major steps. First, we construct a set of 186 real-world Akka actor bugs from Stack Overflow and GitHub via manual analysis of 3,924 Stack Overflow questions, answers, and comments and 3,315 GitHub commits, messages, original and modified code snippets, issues, and pull requests. Second, we manually study these actor bugs and their fixes to understand and classify their symptoms, root causes, and API usages. Third, we study the differences between the commonalities and distributions of symptoms, root causes, and API usages of our Stack Overflow and GitHub actor bugs. Fourth, we discuss real-world examples of our actor bugs with these symptoms and root causes. Finally, we investigate the relation of our findings with those of previous work and discuss their implications. A few findings of our study are: (1) symptoms of our actor bugs can be classified into five categories, with Error as the most common symptom and Incorrect Exceptions as the least common, (2) root causes of our actor bugs can be classified into ten categories, with Logic as the most common root cause and Untyped Communication as the least common, (3) a small number of Akka API packages are responsible for most of API usages by our actor bugs, and (4) our Stack Overflow and GitHub actor bugs can differ significantly in commonalities and distributions of their symptoms, root causes, and API usages. While some of our findings agree with those of previous work, others sharply contrast.},
  author    = {Mehdi Bagherzadeh and Nicholas Fireman and Anas Shawesh and Raffi Khatchadourian},
  doi       = {10.1145/3428282},
  issn      = {24751421},
  issue     = {OOPSLA},
  journal   = {Proceedings of the ACM on Programming Languages},
  keywords  = {Actor bug API usages,Actor bug differences,Actor bug root causes,Actor bug symptoms,Akka actor bugs,GitHub,Stack Overflow},
  month     = {11},
  publisher = {Association for Computing Machinery},
  title     = {Actor concurrency bugs: A comprehensive study on symptoms, root causes, API usages, and differences},
  volume    = {4},
  year      = {2020}
}
@inproceedings{Moradi2023,
  abstract  = {Actor concurrency is becoming increasingly important in the real world and mission-critical software. This requires these applications to be free from actor bugs, that occur in the real world, and have tests that are effective in finding these bugs. Mutation testing is a well-established technique that transforms an application to induce its likely bugs and evaluate the effectiveness of its tests in finding these bugs. Mutation testing is available for a broad spectrum of applications and their bugs, ranging from web to mobile to machine learning, and is used at scale in companies like Google and Facebook. However, there still is no mutation testing for actor concurrency that uses real-world actor bugs. In this paper, we propose Akka, a framework for mutation testing of Akka actor concurrency using real actor bugs. Akka is a popular industrial-strength implementation of actor concurrency. To design, implement, and evaluate Akka, we take the following major steps: (1) manually analyze a recent set of 186 real Akka bugs from Stack Overflow and GitHub to understand their causes; (2) design a set of 32 mutation operators, with 138 source code changes in Akka API, to emulate these causes and induce their bugs; (3) implement these operators in an Eclipse plugin for Java Akka; (4) use the plugin to generate 11.7k mutants of 10 real GitHub applications, with 446.4k lines of code and 7.9k tests; (5) run these tests on these mutants to measure the quality of mutants and effectiveness of tests; (6) use PIT to generate 26.2k mutants to compare Akka and PIT mutant quality and test effectiveness. PIT is a popular mutation testing tool with traditional operators; (7) manually analyze the bug coverage and overlap of Akka, PIT, and actor operators in a previous work; and (8) discuss a few implications of our findings. Among others, we find that Akka mutants are higher quality, cover more bugs, and tests are less effective in detecting them.},
  author    = {Mohsen Moradi Moghadam and Mehdi Bagherzadeh and Raffi Khatchadourian and Hamid Bagheri},
  doi       = {10.1145/3611643.3616362},
  isbn      = {9798400703270},
  booktitle = {ESEC/FSE 2023 - Proceedings of the 31st ACM Joint Meeting European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  keywords  = {Actor concurrency,Akka,Mutant quality,Mutation opertors,Mutation testing,Test effectiveness},
  month     = {11},
  pages     = {262-274},
  publisher = {Association for Computing Machinery, Inc},
  title     = {Akka: Mutation Testing for Actor Concurrency in Akka using Real-World Bugs},
  year      = {2023}
}
@inproceedings{Chaudhary2024,
  abstract  = {Java support the garbage collection automatically. However, with the introduce of JRE7 it introduces the hotspot Architecture having heap, where object data is stored. Garbage Collection based on Responsiveness and Throughput. The overall Automatic Garbage Collection have three steps Marking, Normal Deletion, Deletion with Compacting to complete the cycle. However, the collection of all objects and marking them is difficult with help of JVM. As JVM divides the heap parts as: Young Generation, Old or Tenured Generation and Permanent Generation. To overcome this, we introduce ZGC (Garbage Collector) introduce in Java 11. ZGC is concurrent, region -based, compact, NUMA-aware, using coloured pointers, using load barriers technique. However, with release of Java 21, we introduce Generational ZGC which maintain separate generators for old and young Generation. Generational ZGC heap memory overhead, lower risks of allocation stalls and lower garbage collection CPU overhead. This paper represents ZGC implementation in java as well as the overall advantages, comparison with Generational ZGC.},
  author    = {Ishu Chaudhary and Bhanu Prakash Lohani and Pradeep Kumar Kushwaha and Amar Deep Gupta and Bhuvi Sharma and Jai Sharma},
  doi       = {10.1109/IC3SE62002.2024.10593533},
  isbn      = {9798350366846},
  booktitle = {Proceedings of International Conference on Communication, Computer Sciences and Engineering, IC3SE 2024},
  keywords  = {Garbage Collection,Generational ZGC,Memory Management,ZGC},
  pages     = {631-636},
  publisher = {Institute of Electrical and Electronics Engineers Inc.},
  title     = {Generational ZGC- An Improvement in Garbage Collector in Java 21},
  year      = {2024}
}
@book{Cox-Buday2017,
  abstract  = {First edition. Includes index. Copyright; Table of Contents; Preface; Who Should Read This Book; Navigating This Book; Online Resources; Conventions Used in This Book; Using Code Examples; O'Reilly Safari; How to Contact Us; Acknowledgments; Chapter 1. An Introduction to Concurrency; Moore's Law, Web Scale, and the Mess We're In; Why Is Concurrency Hard?; Race Conditions; Atomicity; Memory Access Synchronization; Deadlocks, Livelocks, and Starvation; Determining Concurrency Safety; Simplicity in the Face of Complexity; Chapter 2. Modeling Your Code: Communicating Sequential Processes.},
  author    = {Katherine. Cox-Buday},
  isbn      = {9781491941195},
  publisher = {O'Reilly Media},
  title     = {Concurrency in Go : tools and techniques for developers},
  year      = {2017}
}
@misc{Kennedy2016,
  author = {Brian Kennedy},
  isbn   = {9781617291784},
  title  = {Go in Action},
  url    = {www.allitebooks.com},
  year   = {2016}
}
@article{Castro2019,
  abstract  = {This paper presents a framework for the static specification and safe programming of message passing protocols where the number and kinds of participants are dynamically instantiated. We develop the first theory of distributed multiparty session types (MPST) to support parameterised protocols with indexed rolesÐour framework statically infers the different kinds of participants induced by a protocol definition as role variants, and produces decoupled endpoint projections of the protocol onto each variant. This enables safe MPST-based programming of the parameterised endpoints in distributed settings: each endpoint can be implemented separately by different programmers, using different techniques (or languages). We prove the decidability of role variant inference and well-formedness checking, and the correctness of projection. We implement our theory as a toolchain for programming such role-parametric MPST protocols in Go. Our approach is to generate API families of lightweight, protocol- and variant-specific type wrappers for I/O. The APIs ensure a well-typed Go endpoint program (by native Go type checking) will perform only compliant I/O actions w.r.t. the source protocol. We leverage the abstractions of MPST to support the specification and implementation of Go applications involving multiple channels, possibly over mixed transports (e.g., Go channels, TCP), and channel passing via a unified programming interface. We evaluate the applicability and run-time performance of our generated APIs using microbenchmarks and real-world applications.},
  author    = {David Castro and Raymond Hu and Sung Shik Jongmans and Nicholas Ng and Nobuko Yoshida},
  doi       = {10.1145/3290342},
  issn      = {24751421},
  issue     = {POPL},
  journal   = {Proceedings of the ACM on Programming Languages},
  keywords  = {Distributed programming,Go,Indexed roles,Multiparty session types},
  month     = {1},
  publisher = {Association for Computing Machinery},
  title     = {Distributed Programming using Role-Parametric Session Types in Go: Statically-typed endpoint APIs for dynamically-instantiated communication structures},
  volume    = {3},
  year      = {2019}
}
@article{Whitney2019,
  abstract  = {In the last decade, the majority of new central processing units (CPU) have become multicore. To take advantage of these new architectures, we need programming languages that can express parallelisms. The programming language Golang is well known for providing developers with an easy programming model for communicating sequential process-style concurrency enabling programmers to easily write functions that will execute on the different cores of a modern multicore CPUs. Unfortunately, Golang does not support distributed execution of goroutines on clusters or distributed systems. In this paper, we extend the concurrency capabilities of Golang to a distributed cluster by providing a library called Gluster that is simple and easy to use. We developed a programming model that allows users to easily distribute work between machines, in a similar way as workloads are distributed in multicore CPUs by using operating system threads with libraries similar to Pthreads and OpenMP. Our Gluster solution is based on a single master node that connects to peers over a network and distributes work to these peers. The master node is able to send function arguments over the network to worker nodes as well as receive return values. Results using matrix multiplication show that our distributed implementation can speed up the goroutines by 5× in a small 16 nodes cluster, but more importantly, it shows that the results are scalable to cluster size.},
  author    = {James Whitney and Chandler Gifford and Maria Pantoja},
  doi       = {10.1007/s11227-018-2649-2},
  issn      = {15730484},
  issue     = {3},
  journal   = {Journal of Supercomputing},
  keywords  = {Cluster,Concurrent programming,Distributed computing,HPC},
  month     = {3},
  pages     = {1396-1409},
  publisher = {Springer New York LLC},
  title     = {Distributed execution of communicating sequential process-style concurrency: Golang case study},
  volume    = {75},
  year      = {2019}
}
@inproceedings{Zhao2023,
  abstract  = {Garbage Collection (GC) is a representative automatic memory manager widely deployed in popular programming languages, such as Java, C\#, and Golang (Go). Through GC, these languages provide programmers with flexibility and safety. However, GC leads to non-trivial overhead in compute and memory resources during application runtime. GC threads compete with non-GC threads (mutators) of an application, which particularly impacts latency-critical (LC) applications and causes long tail latency. Existing GC approaches do not efficiently address the interference, as GC is triggered passively without a global insight of the application; or they employ incremental GC to reduce the interference, while the incremental progress is not dynamically tailored during GC process according to runtime characteristics, which leads to significant performance degradation upon bursty requests. We present LEGO, an efficient and non-intrusive GC framework that deploys a novel elastic incremental GC mechanism integrated with an adaptive GC scheduler to reduce CPU contention between GC and mutators, and improve resource utilization and QoS of LC applications. We choose to develop LEGO in Go, as Go is specifically designed for cloud applications and the current GC mechanisms for JVM are ineffective for Go due to its unique GPM thread scheduling and memory allocation model. LEGO adapts incremental GC into Go to tackle the full GC issue and addresses resource contention with a proactive scheduler for adaptive GC triggering. Importantly, LEGO leverages the elastic incremental GC mechanism in mitigating the interference from unavoidable GC in face of bursts of requests. We implement and evaluate LEGO with popular LC applications developed in Go. Results show that compared to the default Go GC and a tailored G1 GC, LEGO significantly improves both the tail latency and throughput for LC applications.},
  author    = {Junxian Zhao and Xiaobo Zhou and Sang Yoon Chang and Chengzhong Xu},
  doi       = {10.1145/3588195.3592998},
  isbn      = {9798400701559},
  booktitle = {HPDC 2023 - Proceedings of the 32nd International Symposium on High-Performance Parallel and Distributed Computing},
  keywords  = {GC scheduler,Golang (Go),garbage collection (GC),latency critical (LC),tail latency},
  month     = {8},
  pages     = {169-180},
  publisher = {Association for Computing Machinery, Inc},
  title     = {Let It Go: Relieving Garbage Collection Pain for Latency Critical Applications in Golang},
  year      = {2023}
}
@book{Shuiskov2022,
  author    = {Alexander. Shuiskov},
  isbn      = {9781804617007},
  publisher = {PACKT PUBLISHING LIMITED},
  title     = {Microservices With GO : Building Scalable and Reliable Go Microservices},
  year      = {2022}
}
@inproceedings{Zhang2021,
  abstract  = {Well-designed garbage collectors for Java are essential for automatic memory management. Garbage First Garbage Collector (G1GC) is the default garbage collector for JVM, and Z Garbage Collector (ZGC) has been the latest-released garbage collector since JDK 11. These two garbage collectors possess distinctive performance based on different environments. Knowing the different features and performance between these two garbage collectors can help developers to make choices according to their own requirements of garbage collection so that developers can carry out better. Meanwhile, there are relatively less comparative studies between G1GC and ZGC at present. Hence, this paper introduces and compares two garbage collectors and runs an object-creation-and-disposal experiment on G1GC and ZGC to examine their performance in the aspects of heap allocation, CPU usage and time consumption on multiple stages on Java 16. Yield that ZGC unexpectedly has higher throughput and longer total execution time than G1GC, and other attributes are in line with expectations. According to the results, ZGC has a better overall performance than G1GC under the testing circumstances.},
  author    = {Jiayi Zhang},
  doi       = {10.1109/ICFTIC54370.2021.9647167},
  isbn      = {9781665406055},
  booktitle = {2021 IEEE 3rd International Conference on Frontiers Technology of Information and Computer, ICFTIC 2021},
  keywords  = {Comparison,G1,Garbage Collection,Java Garbage Collector,Performance,ZGC},
  pages     = {733-740},
  publisher = {Institute of Electrical and Electronics Engineers Inc.},
  title     = {Performance Comparative Analysis on Garbage First Garbage Collector and Z Garbage Collector},
  year      = {2021}
}
